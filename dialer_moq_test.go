// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gremgo

import (
	"context"
	"sync"
)

var (
	lockdialerMockIsConnected sync.RWMutex
	lockdialerMockIsDisposed  sync.RWMutex
	lockdialerMockclose       sync.RWMutex
	lockdialerMockconnect     sync.RWMutex
	lockdialerMockconnectCtx  sync.RWMutex
	lockdialerMockgetAuth     sync.RWMutex
	lockdialerMockping        sync.RWMutex
	lockdialerMockpingCtx     sync.RWMutex
	lockdialerMockread        sync.RWMutex
	lockdialerMockreadCtx     sync.RWMutex
	lockdialerMockwrite       sync.RWMutex
)

// Ensure, that dialerMock does implement dialer.
// If this is not the case, regenerate this file with moq.
var _ dialer = &dialerMock{}

// dialerMock is a mock implementation of dialer.
//
//     func TestSomethingThatUsesdialer(t *testing.T) {
//
//         // make and configure a mocked dialer
//         mockeddialer := &dialerMock{
//             IsConnectedFunc: func() bool {
// 	               panic("mock out the IsConnected method")
//             },
//             IsDisposedFunc: func() bool {
// 	               panic("mock out the IsDisposed method")
//             },
//             closeFunc: func() error {
// 	               panic("mock out the close method")
//             },
//             connectFunc: func() error {
// 	               panic("mock out the connect method")
//             },
//             connectCtxFunc: func(in1 context.Context) error {
// 	               panic("mock out the connectCtx method")
//             },
//             getAuthFunc: func() *auth {
// 	               panic("mock out the getAuth method")
//             },
//             pingFunc: func(errs chan error)  {
// 	               panic("mock out the ping method")
//             },
//             pingCtxFunc: func(in1 context.Context, in2 chan error)  {
// 	               panic("mock out the pingCtx method")
//             },
//             readFunc: func() (int, []byte, error) {
// 	               panic("mock out the read method")
//             },
//             readCtxFunc: func(in1 context.Context, in2 chan message)  {
// 	               panic("mock out the readCtx method")
//             },
//             writeFunc: func(in1 []byte) error {
// 	               panic("mock out the write method")
//             },
//         }
//
//         // use mockeddialer in code that requires dialer
//         // and then make assertions.
//
//     }
type dialerMock struct {
	// IsConnectedFunc mocks the IsConnected method.
	IsConnectedFunc func() bool

	// IsDisposedFunc mocks the IsDisposed method.
	IsDisposedFunc func() bool

	// closeFunc mocks the close method.
	closeFunc func() error

	// connectFunc mocks the connect method.
	connectFunc func() error

	// connectCtxFunc mocks the connectCtx method.
	connectCtxFunc func(in1 context.Context) error

	// getAuthFunc mocks the getAuth method.
	getAuthFunc func() *auth

	// pingFunc mocks the ping method.
	pingFunc func(errs chan error)

	// pingCtxFunc mocks the pingCtx method.
	pingCtxFunc func(in1 context.Context, in2 chan error)

	// readFunc mocks the read method.
	readFunc func() (int, []byte, error)

	// readCtxFunc mocks the readCtx method.
	readCtxFunc func(in1 context.Context, in2 chan message)

	// writeFunc mocks the write method.
	writeFunc func(in1 []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// IsConnected holds details about calls to the IsConnected method.
		IsConnected []struct {
		}
		// IsDisposed holds details about calls to the IsDisposed method.
		IsDisposed []struct {
		}
		// close holds details about calls to the close method.
		close []struct {
		}
		// connect holds details about calls to the connect method.
		connect []struct {
		}
		// connectCtx holds details about calls to the connectCtx method.
		connectCtx []struct {
			// In1 is the in1 argument value.
			In1 context.Context
		}
		// getAuth holds details about calls to the getAuth method.
		getAuth []struct {
		}
		// ping holds details about calls to the ping method.
		ping []struct {
			// Errs is the errs argument value.
			Errs chan error
		}
		// pingCtx holds details about calls to the pingCtx method.
		pingCtx []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 chan error
		}
		// read holds details about calls to the read method.
		read []struct {
		}
		// readCtx holds details about calls to the readCtx method.
		readCtx []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 chan message
		}
		// write holds details about calls to the write method.
		write []struct {
			// In1 is the in1 argument value.
			In1 []byte
		}
	}
}

// IsConnected calls IsConnectedFunc.
func (mock *dialerMock) IsConnected() bool {
	if mock.IsConnectedFunc == nil {
		panic("dialerMock.IsConnectedFunc: method is nil but dialer.IsConnected was just called")
	}
	callInfo := struct {
	}{}
	lockdialerMockIsConnected.Lock()
	mock.calls.IsConnected = append(mock.calls.IsConnected, callInfo)
	lockdialerMockIsConnected.Unlock()
	return mock.IsConnectedFunc()
}

// IsConnectedCalls gets all the calls that were made to IsConnected.
// Check the length with:
//     len(mockeddialer.IsConnectedCalls())
func (mock *dialerMock) IsConnectedCalls() []struct {
} {
	var calls []struct {
	}
	lockdialerMockIsConnected.RLock()
	calls = mock.calls.IsConnected
	lockdialerMockIsConnected.RUnlock()
	return calls
}

// IsDisposed calls IsDisposedFunc.
func (mock *dialerMock) IsDisposed() bool {
	if mock.IsDisposedFunc == nil {
		panic("dialerMock.IsDisposedFunc: method is nil but dialer.IsDisposed was just called")
	}
	callInfo := struct {
	}{}
	lockdialerMockIsDisposed.Lock()
	mock.calls.IsDisposed = append(mock.calls.IsDisposed, callInfo)
	lockdialerMockIsDisposed.Unlock()
	return mock.IsDisposedFunc()
}

// IsDisposedCalls gets all the calls that were made to IsDisposed.
// Check the length with:
//     len(mockeddialer.IsDisposedCalls())
func (mock *dialerMock) IsDisposedCalls() []struct {
} {
	var calls []struct {
	}
	lockdialerMockIsDisposed.RLock()
	calls = mock.calls.IsDisposed
	lockdialerMockIsDisposed.RUnlock()
	return calls
}

// close calls closeFunc.
func (mock *dialerMock) close() error {
	if mock.closeFunc == nil {
		panic("dialerMock.closeFunc: method is nil but dialer.close was just called")
	}
	callInfo := struct {
	}{}
	lockdialerMockclose.Lock()
	mock.calls.close = append(mock.calls.close, callInfo)
	lockdialerMockclose.Unlock()
	return mock.closeFunc()
}

// closeCalls gets all the calls that were made to close.
// Check the length with:
//     len(mockeddialer.closeCalls())
func (mock *dialerMock) closeCalls() []struct {
} {
	var calls []struct {
	}
	lockdialerMockclose.RLock()
	calls = mock.calls.close
	lockdialerMockclose.RUnlock()
	return calls
}

// connect calls connectFunc.
func (mock *dialerMock) connect() error {
	if mock.connectFunc == nil {
		panic("dialerMock.connectFunc: method is nil but dialer.connect was just called")
	}
	callInfo := struct {
	}{}
	lockdialerMockconnect.Lock()
	mock.calls.connect = append(mock.calls.connect, callInfo)
	lockdialerMockconnect.Unlock()
	return mock.connectFunc()
}

// connectCalls gets all the calls that were made to connect.
// Check the length with:
//     len(mockeddialer.connectCalls())
func (mock *dialerMock) connectCalls() []struct {
} {
	var calls []struct {
	}
	lockdialerMockconnect.RLock()
	calls = mock.calls.connect
	lockdialerMockconnect.RUnlock()
	return calls
}

// connectCtx calls connectCtxFunc.
func (mock *dialerMock) connectCtx(in1 context.Context) error {
	if mock.connectCtxFunc == nil {
		panic("dialerMock.connectCtxFunc: method is nil but dialer.connectCtx was just called")
	}
	callInfo := struct {
		In1 context.Context
	}{
		In1: in1,
	}
	lockdialerMockconnectCtx.Lock()
	mock.calls.connectCtx = append(mock.calls.connectCtx, callInfo)
	lockdialerMockconnectCtx.Unlock()
	return mock.connectCtxFunc(in1)
}

// connectCtxCalls gets all the calls that were made to connectCtx.
// Check the length with:
//     len(mockeddialer.connectCtxCalls())
func (mock *dialerMock) connectCtxCalls() []struct {
	In1 context.Context
} {
	var calls []struct {
		In1 context.Context
	}
	lockdialerMockconnectCtx.RLock()
	calls = mock.calls.connectCtx
	lockdialerMockconnectCtx.RUnlock()
	return calls
}

// getAuth calls getAuthFunc.
func (mock *dialerMock) getAuth() *auth {
	if mock.getAuthFunc == nil {
		panic("dialerMock.getAuthFunc: method is nil but dialer.getAuth was just called")
	}
	callInfo := struct {
	}{}
	lockdialerMockgetAuth.Lock()
	mock.calls.getAuth = append(mock.calls.getAuth, callInfo)
	lockdialerMockgetAuth.Unlock()
	return mock.getAuthFunc()
}

// getAuthCalls gets all the calls that were made to getAuth.
// Check the length with:
//     len(mockeddialer.getAuthCalls())
func (mock *dialerMock) getAuthCalls() []struct {
} {
	var calls []struct {
	}
	lockdialerMockgetAuth.RLock()
	calls = mock.calls.getAuth
	lockdialerMockgetAuth.RUnlock()
	return calls
}

// ping calls pingFunc.
func (mock *dialerMock) ping(errs chan error) {
	if mock.pingFunc == nil {
		panic("dialerMock.pingFunc: method is nil but dialer.ping was just called")
	}
	callInfo := struct {
		Errs chan error
	}{
		Errs: errs,
	}
	lockdialerMockping.Lock()
	mock.calls.ping = append(mock.calls.ping, callInfo)
	lockdialerMockping.Unlock()
	mock.pingFunc(errs)
}

// pingCalls gets all the calls that were made to ping.
// Check the length with:
//     len(mockeddialer.pingCalls())
func (mock *dialerMock) pingCalls() []struct {
	Errs chan error
} {
	var calls []struct {
		Errs chan error
	}
	lockdialerMockping.RLock()
	calls = mock.calls.ping
	lockdialerMockping.RUnlock()
	return calls
}

// pingCtx calls pingCtxFunc.
func (mock *dialerMock) pingCtx(in1 context.Context, in2 chan error) {
	if mock.pingCtxFunc == nil {
		panic("dialerMock.pingCtxFunc: method is nil but dialer.pingCtx was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 chan error
	}{
		In1: in1,
		In2: in2,
	}
	lockdialerMockpingCtx.Lock()
	mock.calls.pingCtx = append(mock.calls.pingCtx, callInfo)
	lockdialerMockpingCtx.Unlock()
	mock.pingCtxFunc(in1, in2)
}

// pingCtxCalls gets all the calls that were made to pingCtx.
// Check the length with:
//     len(mockeddialer.pingCtxCalls())
func (mock *dialerMock) pingCtxCalls() []struct {
	In1 context.Context
	In2 chan error
} {
	var calls []struct {
		In1 context.Context
		In2 chan error
	}
	lockdialerMockpingCtx.RLock()
	calls = mock.calls.pingCtx
	lockdialerMockpingCtx.RUnlock()
	return calls
}

// read calls readFunc.
func (mock *dialerMock) read() (int, []byte, error) {
	if mock.readFunc == nil {
		panic("dialerMock.readFunc: method is nil but dialer.read was just called")
	}
	callInfo := struct {
	}{}
	lockdialerMockread.Lock()
	mock.calls.read = append(mock.calls.read, callInfo)
	lockdialerMockread.Unlock()
	return mock.readFunc()
}

// readCalls gets all the calls that were made to read.
// Check the length with:
//     len(mockeddialer.readCalls())
func (mock *dialerMock) readCalls() []struct {
} {
	var calls []struct {
	}
	lockdialerMockread.RLock()
	calls = mock.calls.read
	lockdialerMockread.RUnlock()
	return calls
}

// readCtx calls readCtxFunc.
func (mock *dialerMock) readCtx(in1 context.Context, in2 chan message) {
	if mock.readCtxFunc == nil {
		panic("dialerMock.readCtxFunc: method is nil but dialer.readCtx was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 chan message
	}{
		In1: in1,
		In2: in2,
	}
	lockdialerMockreadCtx.Lock()
	mock.calls.readCtx = append(mock.calls.readCtx, callInfo)
	lockdialerMockreadCtx.Unlock()
	mock.readCtxFunc(in1, in2)
}

// readCtxCalls gets all the calls that were made to readCtx.
// Check the length with:
//     len(mockeddialer.readCtxCalls())
func (mock *dialerMock) readCtxCalls() []struct {
	In1 context.Context
	In2 chan message
} {
	var calls []struct {
		In1 context.Context
		In2 chan message
	}
	lockdialerMockreadCtx.RLock()
	calls = mock.calls.readCtx
	lockdialerMockreadCtx.RUnlock()
	return calls
}

// write calls writeFunc.
func (mock *dialerMock) write(in1 []byte) error {
	if mock.writeFunc == nil {
		panic("dialerMock.writeFunc: method is nil but dialer.write was just called")
	}
	callInfo := struct {
		In1 []byte
	}{
		In1: in1,
	}
	lockdialerMockwrite.Lock()
	mock.calls.write = append(mock.calls.write, callInfo)
	lockdialerMockwrite.Unlock()
	return mock.writeFunc(in1)
}

// writeCalls gets all the calls that were made to write.
// Check the length with:
//     len(mockeddialer.writeCalls())
func (mock *dialerMock) writeCalls() []struct {
	In1 []byte
} {
	var calls []struct {
		In1 []byte
	}
	lockdialerMockwrite.RLock()
	calls = mock.calls.write
	lockdialerMockwrite.RUnlock()
	return calls
}
